//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2018 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <windows.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ------------------------ Structures ------------------------

struct _FILETIME {
    int32_t e0;
    int32_t e1;
};

struct _OVERLAPPED {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t * e3;
};

struct _SECURITY_ATTRIBUTES {
    int32_t e0;
    int32_t * e1;
    bool e2;
};

struct _SYSTEMTIME {
    int16_t e0;
    int16_t e1;
    int16_t e2;
    int16_t e3;
    int16_t e4;
    int16_t e5;
    int16_t e6;
    int16_t e7;
};

struct tagPOINT {
    int32_t e0;
    int32_t e1;
};

struct tagMSG {
    int32_t * e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    struct tagPOINT e5;
};

struct tagRECT {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
};

struct tagWNDCLASSEXA {
    int32_t e0;
    int32_t e1;
    int32_t (*e2)(int32_t *, int32_t, int32_t, int32_t);
    int32_t e3;
    int32_t e4;
    int32_t * e5;
    int32_t * e6;
    int32_t * e7;
    int32_t * e8;
    char * e9;
    char * e10;
    int32_t * e11;
};

// ------------------- Function Prototypes --------------------

int32_t entry_point(void);
int32_t function_401000(int32_t a1, char * a2, int32_t a3);
int32_t function_4010e1(void);
int32_t function_4010ec(void);
int32_t function_40121d(int128_t * a1, int32_t a2);
int32_t function_4013d7(int128_t * a1, int32_t a2);
int32_t function_40151f(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_401645(struct _SECURITY_ATTRIBUTES * a1, int32_t Msg, uint32_t wParam2, int32_t lParam);
int32_t function_4019f8(void);
int32_t function_401a78(int32_t * hWnd);
int32_t function_401aeb(int32_t * hKey, char * lpSubKey, int32_t Reserved, char * lpClass, int32_t dwOptions, int32_t samDesired, struct _SECURITY_ATTRIBUTES * lpSecurityAttributes, int32_t ** phkResult, int32_t * lpdwDisposition);
int32_t function_401af1(int32_t * hKey);
int32_t function_401af7(int32_t * hKey, char * lpClass, int32_t * lpcchClass, int32_t * lpReserved, int32_t * lpcSubKeys, int32_t * lpcbMaxSubKeyLen, int32_t * lpcbMaxClassLen, int32_t * lpcValues, int32_t * lpcbMaxValueNameLen, int32_t * lpcbMaxValueLen, int32_t * lpcbSecurityDescriptor, struct _FILETIME * lpftLastWriteTime);
int32_t function_401afd(int32_t * hKey, char * lpSubKey);
int32_t * function_401b03(char * lpFileName, int32_t dwDesiredAccess, int32_t dwShareMode, struct _SECURITY_ATTRIBUTES * lpSecurityAttributes, int32_t dwCreationDisposition, int32_t dwFlagsAndAttributes, int32_t * hTemplateFile);
bool function_401b09(int32_t * hObject);
int32_t * function_401b0f(int32_t * hMem);
int32_t * function_401b15(char * lpModuleName);
bool function_401b1b(int32_t * hMem);
void function_401b21(int32_t uExitCode);
bool function_401b27(struct _FILETIME * lpFileTime, struct _SYSTEMTIME * lpSystemTime);
bool function_401b2d(int32_t * hFile, int32_t * lpBuffer, int32_t nNumberOfBytesToWrite, int32_t * lpNumberOfBytesWritten, struct _OVERLAPPED * lpOverlapped);
bool function_401b33(int32_t * hFile, int32_t * lpBuffer, int32_t nNumberOfBytesToRead, int32_t * lpNumberOfBytesRead, struct _OVERLAPPED * lpOverlapped);
int32_t * function_401b39(int32_t uFlags, int32_t dwBytes);
bool function_401b3f(struct _SYSTEMTIME * lpSystemTime, struct _FILETIME * lpFileTime);
int32_t function_401b45(int32_t * hFile, int32_t * lpFileSizeHigh);
int32_t * function_401b4b(int32_t * hMem);
int32_t * function_401b51(int32_t cHeight, int32_t cWidth, int32_t cEscapement, int32_t cOrientation, int32_t cWeight, int32_t bItalic, int32_t bUnderline, int32_t bStrikeOut, int32_t iCharSet, int32_t iOutPrecision, int32_t iClipPrecision, int32_t iQuality, int32_t iPitchAndFamily, char * pszFaceName);
void function_401b57(int32_t nExitCode);
bool function_401b5d(int32_t * hWnd, int32_t Msg, int32_t wParam, int32_t lParam);
bool function_401b63(int32_t * hWnd, int32_t X, int32_t Y, int32_t nWidth, int32_t nHeight, bool bRepaint);
int32_t * function_401b69(int32_t * hInstance, char * lpCursorName);
bool function_401b6f(int32_t * hDlg, struct tagMSG * lpMsg);
bool function_401b75(int32_t * hWnd, struct tagRECT * lpRect);
bool function_401b7b(struct tagMSG * lpMsg, int32_t * hWnd, int32_t wMsgFilterMin, int32_t wMsgFilterMax);
int32_t * function_401b81(int32_t * hInstance, char * lpIconName);
int32_t * function_401b87(void);
int32_t function_401b8d(struct tagMSG * lpMsg);
int32_t function_401b93(int32_t * hWnd, int32_t Msg, int32_t wParam, int32_t lParam);
int16_t function_401b99(struct tagWNDCLASSEXA * lpwcx);
int32_t * function_401b9f(int32_t dwExStyle, char * lpClassName, char * lpWindowName, int32_t dwStyle, int32_t X, int32_t Y, int32_t nWidth, int32_t nHeight, int32_t * hWndParent, int32_t * hMenu, int32_t * hInstance, int32_t * lpParam);
bool function_401ba5(int32_t * hWnd);
bool function_401bab(struct tagMSG * lpMsg);
bool function_401bb1(int32_t * hWnd, int32_t nCmdShow);
int32_t * function_401bb7(int32_t * hWnd);
bool function_401bbd(int32_t * hDlg, int32_t nIDDlgItem, char * lpString);
int32_t function_401bc3(int32_t * hDlg, int32_t nIDDlgItem, int32_t Msg, int32_t wParam, int32_t lParam);

// --------------------- Global Variables ---------------------

int32_t g1 = 0; // eax
int32_t g2 = 0; // ebp
int32_t g3 = 0; // ebx
int32_t g4 = 0; // edi
int32_t g5 = 0; // esi
int32_t g6 = 0; // esp
struct tagWNDCLASSEXA * g7 = NULL;
int32_t g8 = 0;
int32_t g9 = 0;
int32_t g10 = 0;
int32_t g11 = 0;
struct _SECURITY_ATTRIBUTES * g12 = NULL;
int32_t g13 = 0;
int32_t g14 = 0;
int32_t g15 = 0;
int32_t g16 = 0;
char * g17;
int32_t g18 = 0;
int32_t g19 = 0;
int32_t g20 = 0;
struct _FILETIME * g21 = NULL;
struct _SYSTEMTIME * g22 = NULL;
int32_t g23 = -0x3276fa79;
struct tagRECT * g24 = NULL;
int32_t g25 = 0;
int32_t g26 = 0;
int32_t g27 = 0;
struct tagRECT * g28 = NULL;
int32_t g29 = 0;
int32_t g30 = 0;
struct _SECURITY_ATTRIBUTES * g31 = NULL;
int32_t g32 = 0;
char * g33;
char * g34;
int32_t g35 = 0;
int32_t g36 = 0;
int32_t g37 = 0;
int32_t g38 = 0;
int32_t g39 = 0;
int32_t g40 = 0;
int32_t g41 = 0;
int32_t g42 = 0;
int32_t g43 = 0;
int32_t g44 = 0;

// ------------------------ Functions -------------------------

// Address range: 0x401000 - 0x4010e1
int32_t function_401000(int32_t a1, char * a2, int32_t a3) {
    // 0x401000
    if (a3 == 0) {
        // 0x4010dc
        return g1;
    }
    // 0x401013
    g4 = a1;
    int32_t v1 = g2; // bp-32
    int32_t v2 = &v1; // 0x40101d
    int32_t v3 = a1 + 68; // 0x40101d
    // branch -> 0x40101d
    while (true) {
        // 0x40101d
        *(int32_t *)(v2 - 4) = v3;
        function_4010ec();
        int32_t * v4 = (int32_t *)(g6 + 40); // 0x401023
        int32_t v5 = g4; // 0x40102c
        int32_t v6 = *(int32_t *)(v5 + 76); // 0x40102c
        int32_t v7 = *(int32_t *)(v5 + 84); // 0x40102f
        uint32_t v8 = *(int32_t *)(v5 + 88); // 0x401035
        int32_t v9 = v8 / 0x10000 | 0x10000 * *(int32_t *)(*v4 + 80); // 0x4010406
        *(int32_t *)(g6 + 20) = v9 ^ *(int32_t *)g3;
        uint32_t v10 = *(int32_t *)(*v4 + 96); // 0x40104f
        g4 = *(int32_t *)(g6 + 36);
        *(int32_t *)(g6 + 20) = v6 ^ 0x10000 * v8 ^ v10 / 0x10000;
        int32_t v11 = g4; // 0x401066
        uint32_t v12 = *(int32_t *)(v11 + 72); // 0x401066
        int32_t v13 = *(int32_t *)(g6 + 44); // ecx
        *(int32_t *)(g6 + 24) = v7 ^ 0x10000 * v10 ^ v12 / 0x10000;
        int32_t v14 = *(int32_t *)(g4 + 92); // 0x401085
        int32_t v15 = (*(int32_t *)(v11 + 80) / 0x10000 | 0x10000 * v12) ^ v14; // 0x401088
        g1 = v15;
        int32_t v16 = 0; // edx
        *(int32_t *)(g6 + 28) = v15;
        // branch -> 0x401090
        while (true) {
            // 0x401090
            if (v13 == 0) {
                // 0x4010d9
                // branch -> 0x4010dc
                // 0x4010dc
                return g1;
            }
            unsigned char v17 = *(char *)(g6 + 16 + v16); // 0x401094
            g1 = g1 & -256 | (int32_t)v17;
            char * v18 = (char *)g5; // 0x401098
            *v18 = *v18 ^ v17;
            int32_t v19 = v13 - 1; // 0x40109a
            if (v19 == 0) {
                // 0x4010d9
                // branch -> 0x4010dc
                // 0x4010dc
                return g1;
            }
            unsigned char v20 = *(char *)(g6 + 17 + v16); // 0x40109f
            g1 = g1 & -256 | (int32_t)v20;
            char * v21 = (char *)(g5 + 1); // 0x4010a3
            *v21 = *v21 ^ v20;
            int32_t v22 = v19 - 1; // 0x4010a6
            if (v22 == 0) {
                // 0x4010d9
                // branch -> 0x4010dc
                // 0x4010dc
                return g1;
            }
            unsigned char v23 = *(char *)(g6 + 18 + v16); // 0x4010ab
            g1 = g1 & -256 | (int32_t)v23;
            char * v24 = (char *)(g5 + 2); // 0x4010af
            *v24 = *v24 ^ v23;
            if (v22 != 1) {
                unsigned char v25 = *(char *)(g6 + 19 + v16); // 0x4010b7
                g1 = g1 & -256 | (int32_t)v25;
                v13 = v22 - 2;
                char * v26 = (char *)(g5 + 3); // 0x4010bc
                *v26 = *v26 ^ v25;
                v16 += 4;
                g5 += 4;
                *(int32_t *)(g6 + 44) = v13;
                if (v16 >= 16) {
                    // break -> 0x4010ce
                    break;
                }
                // continue -> 0x401090
                continue;
            }
            // 0x4010d9
            // branch -> 0x4010dc
            // 0x4010dc
            return g1;
        }
        // 0x4010ce
        if (v13 == 0) {
            // 0x4010d9
            // branch -> 0x4010dc
            // 0x4010dc
            return g1;
        }
        // 0x4010ce
        v2 = g6;
        v3 = g4 + 68;
        // branch -> 0x40101d
    }
}

// Address range: 0x4010e1 - 0x4010ec
int32_t function_4010e1(void) {
    // 0x4010e1
    int64_t v1;
    int64_t v2 = v1 & 0xffffffff; // 0x4010e7
    uint64_t v3 = v2 * v2; // 0x4010e7
    return v3 / 0x100000000 ^ v3;
}

// Address range: 0x4010ec - 0x40121d
int32_t function_4010ec(void) {
    // 0x4010ec
    int32_t v1;
    int32_t * v2 = (int32_t *)(v1 + 32); // 0x401105
    uint32_t v3 = *v2; // 0x401105
    uint32_t v4 = *(int32_t *)(v1 + 64) + 0x4d34d34d + v3; // 0x40110d
    *v2 = v4;
    int32_t v5 = v4 < v3; // 0x401114
    int32_t v6 = 0; // edi
    *(int32_t *)(v6 + 64) = v5;
    int32_t * v7 = (int32_t *)(v6 + 36); // 0x401120
    uint32_t v8 = *v7; // 0x401120
    uint32_t v9 = v8 + v5 - 0x2cb2cb2d; // 0x401123
    *v7 = v9;
    int32_t v10 = v9 < v8; // 0x40112a
    *(int32_t *)(v6 + 64) = v10;
    int32_t * v11 = (int32_t *)(v6 + 40); // 0x401136
    uint32_t v12 = *v11; // 0x401136
    uint32_t v13 = v12 + v10 + 0x34d34d34; // 0x401139
    *v11 = v13;
    int32_t v14 = v13 < v12; // 0x401140
    *(int32_t *)(v6 + 64) = v14;
    int32_t * v15 = (int32_t *)(v6 + 44); // 0x40114c
    uint32_t v16 = *v15; // 0x40114c
    uint32_t v17 = v16 + v14 + 0x4d34d34d; // 0x40114f
    *v15 = v17;
    int32_t v18 = v17 < v16; // 0x401156
    *(int32_t *)(v6 + 64) = v18;
    int32_t * v19 = (int32_t *)(v6 + 48); // 0x401162
    uint32_t v20 = *v19; // 0x401162
    uint32_t v21 = v20 + v18 - 0x2cb2cb2d; // 0x401165
    *v19 = v21;
    int32_t v22 = v21 < v20; // 0x40116c
    *(int32_t *)(v6 + 64) = v22;
    int32_t * v23 = (int32_t *)(v6 + 52); // 0x401178
    uint32_t v24 = *v23; // 0x401178
    uint32_t v25 = v24 + v22 + 0x34d34d34; // 0x40117b
    *v23 = v25;
    int32_t v26 = v25 < v24; // 0x401182
    *(int32_t *)(v6 + 64) = v26;
    int32_t * v27 = (int32_t *)(v6 + 56); // 0x40118e
    uint32_t v28 = *v27; // 0x40118e
    uint32_t v29 = v28 + v26 + 0x4d34d34d; // 0x401191
    *v27 = v29;
    int32_t v30 = v29 < v28; // 0x401198
    *(int32_t *)(v6 + 64) = v30;
    int32_t * v31 = (int32_t *)(v6 + 60); // 0x4011a4
    uint32_t v32 = *v31; // 0x4011a4
    uint32_t v33 = v32 + v30 - 0x2cb2cb2d; // 0x4011a7
    *v31 = v33;
    int32_t v34; // bp-32
    int32_t v35 = &v34; // 0x4011b2
    *(int32_t *)(v6 + 64) = (int32_t)(v33 < v32);
    int32_t v36 = 0; // esi
    int32_t v37 = v36; // 0x4011b7
    *(int32_t *)(g6 - 4) = *(int32_t *)v37 + *(int32_t *)(v37 + 32);
    *(int32_t *)(v35 - v6 + v36) = function_4010e1();
    int32_t v38 = v36 + 4; // 0x4011c8
    v36 = v38;
    int32_t v39 = 7; // 0x4011cb
    // branch -> 0x4011b7
    while (v39 != 0) {
        // 0x4011b7
        v37 = v38;
        *(int32_t *)(g6 - 4) = *(int32_t *)v37 + *(int32_t *)(v37 + 32);
        *(int32_t *)(v35 - v6 + v36) = function_4010e1();
        v38 = v36 + 4;
        v36 = v38;
        v39--;
        // continue -> 0x4011b7
    }
    // 0x4011d0
    v36 = 0;
    int32_t result = 7; // eax
    int32_t v40 = 0; // 0x4011f1
    int32_t v41 = 7; // 0x4011e7
    // branch -> 0x4011d7
    while (true) {
        int32_t v42 = 4 * v41; // 0x4011d7
        uint32_t v43 = *(int32_t *)(g6 + 12 + v42); // 0x4011d7
        int32_t v44 = g6 + 16; // 0x4011db
        uint32_t v45 = *(int32_t *)(v44 + v42); // 0x4011db
        int32_t v46 = 4 * v40; // 0x4011ea
        int32_t v47 = *(int32_t *)(v44 + v46); // 0x4011ea
        *(int32_t *)(v6 + v46) = v47 + (v45 / 0x10000 | 0x10000 * v45) + (v43 / 0x10000 | 0x10000 * v43);
        int32_t v48 = g6 + 16; // 0x4011f4
        uint32_t v49 = *(int32_t *)(4 * ((v41 + 1) % 8) + v48); // 0x4011f4
        int32_t v50 = result; // 0x4011fb
        int32_t v51 = *(int32_t *)(4 * v50 + v48) + (v49 / 0x1000000 | 256 * v49); // 0x4011fb
        int32_t v52 = 4 * v36; // 0x401202
        int32_t v53 = *(int32_t *)(g6 + 20 + v52) + v51; // 0x401202
        result = (v50 + 2) % 8;
        *(int32_t *)(v52 + 4 + v6) = v53;
        int32_t v54 = v36 + 2; // 0x40120d
        v36 = v54;
        if (v54 >= 8) {
            // 0x401215
            g4 = *(int32_t *)g6;
            g5 = *(int32_t *)(g6 + 4);
            g3 = *(int32_t *)(g6 + 12);
            return result;
        }
        // 0x4011d7
        v40 = v54;
        v41 = result;
        // branch -> 0x4011d7
    }
}

// Address range: 0x40121d - 0x4013d7
int32_t function_40121d(int128_t * a1, int32_t a2) {
    int32_t v1 = *(int32_t *)(a2 + 4); // 0x401227
    int32_t v2 = v1; // ebx
    int32_t v3 = (int32_t)a1; // 0x40122c
    int32_t v4 = v3; // esi
    uint32_t v5 = *(int32_t *)a2; // 0x401237
    int32_t v6 = v5 / 0x10000 | v1 & -0x10000; // ecx
    int32_t v7 = v5 % 0x10000 | 0x10000 * v1; // edx
    *(int32_t *)(v3 + 100) = *(int32_t *)(v3 + 32) ^ v5;
    int32_t v8 = v4; // 0x40125a
    *(int32_t *)(v8 + 104) = v6 ^ *(int32_t *)(v8 + 36);
    int32_t v9 = v4; // 0x401262
    *(int32_t *)(v9 + 108) = v2 ^ *(int32_t *)(v9 + 40);
    int32_t v10 = v4; // 0x40126a
    *(int32_t *)(v10 + 112) = v7 ^ *(int32_t *)(v10 + 44);
    int32_t v11 = v4; // 0x401272
    int32_t v12 = v11 + 68; // edi
    *(int32_t *)(v11 + 116) = v5 ^ *(int32_t *)(v11 + 48);
    int32_t v13 = v4; // 0x40127d
    *(int32_t *)(v13 + 120) = v6 ^ *(int32_t *)(v13 + 52);
    int32_t v14 = v4; // 0x401285
    *(int32_t *)(v14 + 124) = v2 ^ *(int32_t *)(v14 + 56);
    int32_t v15 = v4; // 0x40128d
    *(int32_t *)(v15 + 128) = v7 ^ *(int32_t *)(v15 + 60);
    int128_t v16 = __asm_movups(*(int128_t *)v4); // 0x401298
    __asm_movups_1(*(int128_t *)v12, v16);
    int128_t v17 = __asm_movups(*(int128_t *)(v4 + 16)); // 0x40129e
    __asm_movups_1(*(int128_t *)(v12 + 16), v17);
    // branch -> 0x4012a6
  lab_0x4012a6:
    while (true) {
        int32_t * v18 = (int32_t *)(v12 + 32); // 0x4012ad
        uint32_t v19 = *v18; // 0x4012ad
        uint32_t v20 = *(int32_t *)(v12 + 64) + 0x4d34d34d + v19; // 0x4012b5
        v4 = v12;
        *v18 = v20;
        int32_t v21 = v20 < v19; // 0x4012c3
        *(int32_t *)(v12 + 64) = v21;
        int32_t * v22 = (int32_t *)(v12 + 36); // 0x4012cf
        uint32_t v23 = *v22; // 0x4012cf
        uint32_t v24 = v23 + v21 - 0x2cb2cb2d; // 0x4012d2
        *v22 = v24;
        int32_t v25 = v24 < v23; // 0x4012d9
        *(int32_t *)(v12 + 64) = v25;
        int32_t * v26 = (int32_t *)(v12 + 40); // 0x4012e5
        uint32_t v27 = *v26; // 0x4012e5
        uint32_t v28 = v27 + v25 + 0x34d34d34; // 0x4012e8
        *v26 = v28;
        int32_t v29 = v28 < v27; // 0x4012ef
        *(int32_t *)(v12 + 64) = v29;
        int32_t * v30 = (int32_t *)(v12 + 44); // 0x4012fb
        uint32_t v31 = *v30; // 0x4012fb
        uint32_t v32 = v31 + v29 + 0x4d34d34d; // 0x4012fe
        *v30 = v32;
        int32_t v33 = v32 < v31; // 0x401305
        *(int32_t *)(v12 + 64) = v33;
        int32_t * v34 = (int32_t *)(v12 + 48); // 0x401311
        uint32_t v35 = *v34; // 0x401311
        uint32_t v36 = v35 + v33 - 0x2cb2cb2d; // 0x401314
        *v34 = v36;
        int32_t v37 = v36 < v35; // 0x40131b
        *(int32_t *)(v12 + 64) = v37;
        int32_t * v38 = (int32_t *)(v12 + 52); // 0x401327
        uint32_t v39 = *v38; // 0x401327
        uint32_t v40 = v39 + v37 + 0x34d34d34; // 0x40132a
        *v38 = v40;
        int32_t v41 = v40 < v39; // 0x401331
        *(int32_t *)(v12 + 64) = v41;
        int32_t * v42 = (int32_t *)(v12 + 56); // 0x40133d
        uint32_t v43 = *v42; // 0x40133d
        uint32_t v44 = v43 + v41 + 0x4d34d34d; // 0x401340
        *v42 = v44;
        int32_t v45 = v44 < v43; // 0x401347
        *(int32_t *)(v12 + 64) = v45;
        int32_t * v46 = (int32_t *)(v12 + 60); // 0x401353
        uint32_t v47 = *v46; // 0x401353
        uint32_t v48 = v47 + v45 - 0x2cb2cb2d; // 0x401356
        *v46 = v48;
        *(int32_t *)(v12 + 64) = (int32_t)(v48 < v47);
        int32_t v49 = v4; // 0x401366
        *(int32_t *)(g6 - 4) = *(int32_t *)v49 + *(int32_t *)(v49 + 32);
        *(int32_t *)(g6 + 16 - v12 + v4) = function_4010e1();
        int32_t v50 = v4 + 4; // 0x401377
        v4 = v50;
        int32_t v51 = 7; // 0x40137a
        // branch -> 0x401366
        while (v51 != 0) {
            // 0x401366
            v49 = v50;
            *(int32_t *)(g6 - 4) = *(int32_t *)v49 + *(int32_t *)(v49 + 32);
            *(int32_t *)(g6 + 16 - v12 + v4) = function_4010e1();
            v50 = v4 + 4;
            v4 = v50;
            v51--;
            // continue -> 0x401366
        }
        // 0x40137f
        v4 = 0;
        int32_t result = 7; // eax
        int32_t v52 = 0; // 0x4013a0
        int32_t v53 = 7; // 0x401396
        // branch -> 0x401386
        while (true) {
            int32_t v54 = 4 * v53; // 0x401386
            uint32_t v55 = *(int32_t *)(g6 + 12 + v54); // 0x401386
            int32_t v56 = g6 + 16; // 0x40138a
            uint32_t v57 = *(int32_t *)(v56 + v54); // 0x40138a
            int32_t v58 = (v57 / 0x10000 | 0x10000 * v57) + (v55 / 0x10000 | 0x10000 * v55); // 0x401394
            int32_t v59 = 4 * v52; // 0x401399
            int32_t v60 = *(int32_t *)(v56 + v59) + v58; // 0x401399
            *(int32_t *)(v12 + v59) = v60;
            int32_t v61 = g6 + 16; // 0x4013a3
            uint32_t v62 = *(int32_t *)(4 * ((v53 + 1) % 8) + v61); // 0x4013a3
            int32_t v63 = result; // 0x4013aa
            int32_t v64 = *(int32_t *)(4 * v63 + v61) + (v62 / 0x1000000 | 256 * v62); // 0x4013aa
            int32_t v65 = 4 * v4; // 0x4013b1
            int32_t v66 = *(int32_t *)(g6 + 20 + v65) + v64; // 0x4013b1
            result = (v63 + 2) % 8;
            *(int32_t *)(v65 + 4 + v12) = v66;
            int32_t v67 = v4 + 2; // 0x4013bc
            v4 = v67;
            if (v67 < 8) {
                // 0x401386
                v52 = v67;
                v53 = result;
                // branch -> 0x401386
                continue;
            } else {
                int32_t * v68 = (int32_t *)(g6 + 56); // 0x4013c4
                int32_t v69 = *v68 - 1; // 0x4013c4
                *v68 = v69;
                if (v69 == 0) {
                    // break (via goto) -> 0x4013cf
                    goto lab_0x4013cf;
                }
                // continue (via goto) -> 0x4012a6
                goto lab_0x4012a6;
            }
        }
      lab_0x4013cf:
        // 0x4013cf
        g5 = *(int32_t *)(g6 + 4);
        g2 = *(int32_t *)(g6 + 8);
        return result;
    }
}

// Address range: 0x4013d7 - 0x4014fb
int32_t function_4013d7(int128_t * a1, int32_t a2) {
    int32_t v1 = *(int32_t *)(a2 + 12); // 0x4013de
    int32_t v2 = *(int32_t *)(a2 + 4); // edx
    int32_t v3 = *(int32_t *)a2; // ebp
    int32_t v4 = (int32_t)a1; // 0x4013e8
    g5 = v4;
    uint32_t v5 = *(int32_t *)(a2 + 8); // 0x4013f0
    int32_t v6 = v5; // edi
    *(int32_t *)(v4 + 16) = v5;
    *(int32_t *)(g5 + 4) = v5 / 0x10000 | 0x10000 * v1;
    *(int32_t *)g5 = v3;
    *(int32_t *)(g5 + 12) = v1 / 0x10000 | 0x10000 * v3;
    *(int32_t *)(g5 + 8) = v2;
    *(int32_t *)(g5 + 20) = 0x10000 * v2 | v3 / 0x10000;
    *(int32_t *)(g5 + 24) = v1;
    *(int32_t *)(g5 + 28) = 0x10000 * v6 | v2 / 0x10000;
    *(int32_t *)(g5 + 32) = v6 / 0x10000 | 0x10000 * v6;
    *(int32_t *)(g5 + 40) = v1 / 0x10000 | 0x10000 * v1;
    *(int32_t *)(g5 + 48) = v3 / 0x10000 | 0x10000 * v3;
    *(int32_t *)(g5 + 56) = v2 / 0x10000 | 0x10000 * v2;
    *(int32_t *)(g5 + 64) = 0;
    uint32_t v7 = v3 ^ v2; // 0x401460
    *(int32_t *)(g5 + 36) = v3 ^ v7 % 0x10000;
    *(int32_t *)(g5 + 44) = (v2 ^ v6) % 0x10000 ^ v2;
    g4 = 4;
    *(int32_t *)(g5 + 52) = (v6 ^ v1) % 0x10000 ^ v6;
    *(int32_t *)(g5 + 60) = (v3 ^ v1) % 0x10000 ^ v1;
    *(int32_t *)(g6 - 4) = g5;
    function_4010ec();
    int32_t v8 = g4 - 1; // 0x40149a
    g4 = v8;
    // branch -> 0x401491
    while (v8 != 0) {
        // 0x401491
        *(int32_t *)g6 = g5;
        function_4010ec();
        v8 = g4 - 1;
        g4 = v8;
        // continue -> 0x401491
    }
    int32_t * v9 = (int32_t *)(g5 + 32); // 0x4014a2
    *v9 = *v9 ^ *(int32_t *)(g5 + 16);
    int32_t * v10 = (int32_t *)(g5 + 36); // 0x4014a8
    *v10 = *v10 ^ *(int32_t *)(g5 + 20);
    int32_t * v11 = (int32_t *)(g5 + 40); // 0x4014ae
    *v11 = *v11 ^ *(int32_t *)(g5 + 24);
    int32_t * v12 = (int32_t *)(g5 + 44); // 0x4014b4
    *v12 = *v12 ^ *(int32_t *)(g5 + 28);
    int32_t * v13 = (int32_t *)(g5 + 48); // 0x4014b9
    *v13 = *v13 ^ *(int32_t *)g5;
    int32_t * v14 = (int32_t *)(g5 + 52); // 0x4014bf
    *v14 = *v14 ^ *(int32_t *)(g5 + 4);
    int32_t * v15 = (int32_t *)(g5 + 56); // 0x4014c5
    *v15 = *v15 ^ *(int32_t *)(g5 + 8);
    int32_t * v16 = (int32_t *)(g5 + 60); // 0x4014cb
    *v16 = *v16 ^ *(int32_t *)(g5 + 12);
    int128_t v17 = __asm_movups(*(int128_t *)g5); // 0x4014ce
    int32_t result = *(int32_t *)(g5 + 64); // eax
    g4 = *(int32_t *)g6;
    __asm_movups_1(*(int128_t *)(g5 + 68), v17);
    int128_t v18 = __asm_movups(*(int128_t *)(g5 + 16)); // 0x4014d9
    __asm_movups_1(*(int128_t *)(g5 + 84), v18);
    int128_t v19 = __asm_movups(*(int128_t *)(g5 + 32)); // 0x4014e1
    __asm_movups_1(*(int128_t *)(g5 + 100), v19);
    int128_t v20 = __asm_movups(*(int128_t *)(g5 + 48)); // 0x4014e9
    __asm_movups_1(*(int128_t *)(g5 + 116), v20);
    *(int32_t *)(g5 + 132) = result;
    g5 = *(int32_t *)g6;
    return result;
}

// Address range: 0x4014fb - 0x40151f
int32_t entry_point(void) {
    int32_t * moduleHandle = GetModuleHandleA(NULL); // 0x4014fd
    g31 = (struct _SECURITY_ATTRIBUTES *)moduleHandle;
    function_40151f((int32_t)moduleHandle, 0, 0, 10);
    ExitProcess(0);
    int32_t * v1;
    return (int32_t)&v1;
}

// Address range: 0x40151f - 0x401645
int32_t function_40151f(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x40151f
    g7 = (struct tagWNDCLASSEXA *)48;
    g8 = 0;
    g9 = 0x401645;
    g10 = 0;
    g11 = 0;
    int32_t v1 = *(int32_t *)&g31; // 0x40155510
    *(int32_t *)&g12 = v1;
    int32_t iconHandle = (int32_t)LoadIconA(&((struct _SECURITY_ATTRIBUTES *)v1)->e0, (char *)0x1388); // 0x40156c
    g32 = iconHandle;
    g13 = iconHandle;
    g14 = (int32_t)LoadCursorA(NULL, (char *)0x7f00);
    g15 = 5;
    g16 = 0;
    g17 = "flag_cryptor";
    RegisterClassExA((struct tagWNDCLASSEXA *)&g7);
    int32_t v2 = *(int32_t *)&g31; // 0x4015b613
    int32_t * windowHandle = CreateWindowExA(512, "flag_cryptor", "Hackvent 2018", 0xca0000, -0x80000000, -0x80000000, 400, 120, NULL, NULL, &((struct _SECURITY_ATTRIBUTES *)v2)->e0, NULL); // 0x4015e5
    struct tagMSG * hWnd = (struct tagMSG *)windowHandle; // bp-80
    ShowWindow(windowHandle, 1);
    struct tagMSG * lpMsg = (struct tagMSG *)windowHandle; // bp-84
    UpdateWindow(windowHandle);
    // branch -> 0x4015ff
    while (true) {
      lab_0x4015ff:
        // 0x4015ff
        *(int32_t *)(g6 - 4) = 0;
        *(int32_t *)(g6 - 8) = 0;
        *(int32_t *)(g6 - 12) = 0;
        *(int32_t *)(g6 - 16) = (int32_t)&g18;
        if (!GetMessageA(lpMsg, (int32_t *)hWnd, 1, 512)) {
            // 0x40163c
            return g19;
        }
        // 0x401614
        *(int32_t *)(g6 - 4) = (int32_t)&g18;
        *(int32_t *)(g6 - 8) = (int32_t)windowHandle;
        if (!IsDialogMessageA((int32_t *)lpMsg, hWnd)) {
            // break -> 0x401626
            break;
        }
        // continue -> 0x4015ff
    }
    // 0x401626
    *(int32_t *)(g6 - 4) = (int32_t)&g18;
    TranslateMessage(lpMsg);
    *(int32_t *)(g6 - 4) = (int32_t)&g18;
    DispatchMessageA(lpMsg);
    // branch -> 0x4015ff
    goto lab_0x4015ff;
}

// Address range: 0x401645 - 0x4019f8
int32_t function_401645(struct _SECURITY_ATTRIBUTES * a1, int32_t Msg, uint32_t wParam2, int32_t lParam) {
    struct _SECURITY_ATTRIBUTES * v1 = a1;
    if (Msg == 1) {
        int32_t v2 = *(int32_t *)&g31; // 0x40165511
        int32_t * windowHandle = CreateWindowExA(512, "STATIC", NULL, 0x50010081, 12, 20, 366, 20, &a1->e0, (int32_t *)2000, &((struct _SECURITY_ATTRIBUTES *)v2)->e0, NULL); // 0x40167f
        g41 = (int32_t)windowHandle;
        SetFocus(windowHandle);
        int32_t v3 = *(int32_t *)&g31; // 0x40169113
        CreateWindowExA(0x20000, "BUTTON", "Encrypt", 0x50010000, 12, 50, 60, 28, &a1->e0, (int32_t *)3000, &((struct _SECURITY_ATTRIBUTES *)v3)->e0, NULL);
        int32_t v4 = *(int32_t *)&g31; // 0x4016c214
        CreateWindowExA(0x20000, "BUTTON", "Exit", 0x50010000, 318, 50, 60, 28, &a1->e0, (int32_t *)4000, &((struct _SECURITY_ATTRIBUTES *)v4)->e0, NULL);
        function_401a78(&a1->e0);
        int32_t wParam = (int32_t)CreateFontA(16, 0, 0, 0, 400, 0, 0, 0, 1, 0, 0, 0, 0, "Calibri"); // 0x40171e
        g40 = wParam;
        SendDlgItemMessageA(&a1->e0, 2000, 48, wParam, 0);
        SendDlgItemMessageA(&a1->e0, 3000, 48, g40, 0);
        SendDlgItemMessageA(&a1->e0, 4000, 48, g40, 0);
        int32_t result = SetDlgItemTextA(&a1->e0, 2000, "flag encryptor ready - press encrypt"); // 0x40177a
        // branch -> 0x4019f4
        // 0x4019f4
        return result;
    }
    // 0x401784
    int32_t result3; // 0x4019f5
    int32_t * v5;
    if (Msg != 273) {
        // 0x4019b7
        if (Msg == 513) {
            int32_t result2 = PostMessageA(&a1->e0, 161, 2, lParam); // 0x4019cd
            // branch -> 0x4019f4
            // 0x4019f4
            return result2;
        }
        // 0x4019d4
        if (Msg != 2) {
            // 0x4019e3
            result3 = DefWindowProcA(&a1->e0, Msg, wParam2, lParam);
            // branch -> 0x4019f4
        } else {
            // 0x4019da
            PostQuitMessage(0);
            result3 = (int32_t)&v5;
            // branch -> 0x4019f4
        }
        // 0x4019f4
        return result3;
    }
    uint32_t v6 = wParam2 % 0x10000; // 0x401791
    if (v6 != 3000) {
        // 0x4019a5
        if (v6 != 4000) {
            // 0x4019a5
            int32_t v7; // eax
            result3 = v7;
            // branch -> 0x4019f4
        } else {
            // 0x4019ae
            PostQuitMessage(0);
            result3 = (int32_t)&v5;
            // branch -> 0x4019f4
        }
        // 0x4019f4
        return result3;
    }
    int32_t * fileHandle = CreateFileA("flag", -0x40000000, 3, NULL, 3, 0, NULL); // 0x4017b9
    int32_t result4;
    if (fileHandle == (int32_t *)-1) {
        bool v8 = SetDlgItemTextA(&a1->e0, 2000, "error: could not open file - supply a flag please"); // 0x40199e
        result4 = v8;
        // branch -> 0x4019a3
    } else {
        // 0x4017c7
        g33 = (char *)fileHandle;
        uint32_t v9 = GetFileSize(fileHandle, NULL); // 0x4017d4
        g34 = (char *)v9;
        int32_t dwBytes = v9; // 0x4017f222
        if (v9 % 2 != 0) {
            int32_t v10 = v9 + 1; // 0x4017ec
            g34 = (char *)v10;
            dwBytes = v10;
            // branch -> 0x4017f2
        }
        int32_t * hMem = GlobalAlloc(64, dwBytes); // 0x4017fa
        g35 = (int32_t)hMem;
        int32_t * lpBuffer = GlobalLock(hMem); // 0x401805
        g36 = (int32_t)lpBuffer;
        int32_t nNumberOfBytesToRead = *(int32_t *)&g34; // 0x40181723
        int32_t hFile = *(int32_t *)&g33; // 0x40182324
        ReadFile((int32_t *)hFile, lpBuffer, nNumberOfBytesToRead, &g39, NULL);
        int32_t hObject = *(int32_t *)&g33; // 0x40182e25
        CloseHandle((int32_t *)hObject);
        int32_t hObject2; // bp-136
        if (*(int32_t *)hObject == 0x474e5089) {
            int32_t dwBytes2 = (int32_t)g34 / 2; // 0x40185e
            g42 = dwBytes2;
            int32_t * hMem2 = GlobalAlloc(64, dwBytes2); // 0x401868
            g37 = (int32_t)hMem2;
            int32_t v11 = (int32_t)GlobalLock(hMem2); // 0x401873
            g38 = v11;
            int32_t v12 = 0; // ecx
            g5 = g36;
            g4 = v11;
            int32_t nNumberOfBytesToWrite; // 0x401931
            int32_t * fileHandle2; // 0x40191b
            int32_t * v13; // 0x40198a
            int32_t v14; // 0x40195228
            struct _SECURITY_ATTRIBUTES * v15; // 0x401966
            if (g42 != 0) {
                int32_t v16 = 0; // 0x4018a0
                int32_t v17 = 0; // 0x401897
                int32_t v18 = 0; // 0x4018a9
                int32_t v19 = g36; // 0x4018a0
                while (true) {
                    int32_t v20 = 2 * v18; // 0x401897
                    int32_t v21 = v17 & -256; // 0x40189d
                    int32_t v22 = (int32_t)(*(char *)(v20 + v19) & -16) | v21; // 0x40189d
                    int32_t v23 = (int32_t)(*(char *)(v19 + 1 + v20) / 16) | v16 & -256; // 0x4018a4
                    uint32_t v24 = v23 | v22; // 0x4018a727
                    *(char *)(v18 + v11) = (char)v24;
                    int32_t v25 = v12 + 1; // 0x4018ac
                    v12 = v25;
                    if (v25 == g42) {
                        // 0x40188f
                        // branch -> 0x4018af
                        // 0x4018af
                        GlobalUnlock((int32_t *)g36);
                        GlobalFree((int32_t *)g35);
                        function_4019f8();
                        function_4013d7((int128_t *)&g20, (int32_t)&g23);
                        g1 = function_40121d((int128_t *)&g20, (int32_t)&g21);
                        function_401000((int32_t)&g20, (char *)g38, g42);
                        fileHandle2 = CreateFileA("flag_encrypted", -0x40000000, 3, NULL, 2, 0, NULL);
                        if (fileHandle2 == (int32_t *)-1) {
                            // 0x40195c
                            v15 = v1;
                            hObject2 = (int32_t)v15;
                            SetDlgItemTextA(&v15->e0, 2000, "error: could not write the encrypted flag");
                            // branch -> 0x40196e
                            // 0x40196e
                            *(int32_t *)(g6 - 4) = g43;
                            CloseHandle((int32_t *)hObject2);
                            *(int32_t *)(g6 - 4) = g38;
                            GlobalUnlock((int32_t *)hObject2);
                            *(int32_t *)(g6 - 4) = g37;
                            v13 = GlobalFree((int32_t *)hObject2);
                            // branch -> 0x4019a3
                            // 0x4019a3
                            // branch -> 0x4019f4
                            // 0x4019f4
                            return (int32_t)v13;
                        }
                        // 0x401925
                        g43 = (int32_t)fileHandle2;
                        nNumberOfBytesToWrite = g42;
                        hObject2 = nNumberOfBytesToWrite;
                        if (WriteFile(fileHandle2, (int32_t *)g38, nNumberOfBytesToWrite, &g39, NULL)) {
                            // 0x401948
                            v14 = *(int32_t *)&v1;
                            SetDlgItemTextA(&((struct _SECURITY_ATTRIBUTES *)v14)->e0, 2000, "success: flag encrypted and written to disk");
                            // branch -> 0x40196e
                            // 0x40196e
                            *(int32_t *)(g6 - 4) = g43;
                            CloseHandle((int32_t *)hObject2);
                            *(int32_t *)(g6 - 4) = g38;
                            GlobalUnlock((int32_t *)hObject2);
                            *(int32_t *)(g6 - 4) = g37;
                            v13 = GlobalFree((int32_t *)hObject2);
                            // branch -> 0x4019a3
                            // 0x4019a3
                            // branch -> 0x4019f4
                            // 0x4019f4
                            return (int32_t)v13;
                        }
                        // 0x40196e
                        *(int32_t *)(g6 - 4) = g43;
                        CloseHandle((int32_t *)hObject2);
                        *(int32_t *)(g6 - 4) = g38;
                        GlobalUnlock((int32_t *)hObject2);
                        *(int32_t *)(g6 - 4) = g37;
                        v13 = GlobalFree((int32_t *)hObject2);
                        // branch -> 0x4019a3
                        // 0x4019a3
                        // branch -> 0x4019f4
                        // 0x4019f4
                        return (int32_t)v13;
                    }
                    // 0x401897
                    v11 = g4;
                    v16 = v23;
                    v17 = v24 % 256 | v21;
                    v18 = v25;
                    v19 = g5;
                    // branch -> 0x401897
                }
            }
            // 0x4018af
            GlobalUnlock((int32_t *)g36);
            GlobalFree((int32_t *)g35);
            function_4019f8();
            function_4013d7((int128_t *)&g20, (int32_t)&g23);
            g1 = function_40121d((int128_t *)&g20, (int32_t)&g21);
            function_401000((int32_t)&g20, (char *)g38, g42);
            fileHandle2 = CreateFileA("flag_encrypted", -0x40000000, 3, NULL, 2, 0, NULL);
            if (fileHandle2 == (int32_t *)-1) {
                // 0x40195c
                v15 = v1;
                hObject2 = (int32_t)v15;
                SetDlgItemTextA(&v15->e0, 2000, "error: could not write the encrypted flag");
                // branch -> 0x40196e
            } else {
                // 0x401925
                g43 = (int32_t)fileHandle2;
                nNumberOfBytesToWrite = g42;
                hObject2 = nNumberOfBytesToWrite;
                if (WriteFile(fileHandle2, (int32_t *)g38, nNumberOfBytesToWrite, &g39, NULL)) {
                    // 0x401948
                    v14 = *(int32_t *)&v1;
                    SetDlgItemTextA(&((struct _SECURITY_ATTRIBUTES *)v14)->e0, 2000, "success: flag encrypted and written to disk");
                    // branch -> 0x40196e
                }
            }
            // 0x40196e
            *(int32_t *)(g6 - 4) = g43;
            CloseHandle((int32_t *)hObject2);
            *(int32_t *)(g6 - 4) = g38;
            GlobalUnlock((int32_t *)hObject2);
            *(int32_t *)(g6 - 4) = g37;
            v13 = GlobalFree((int32_t *)hObject2);
            // branch -> 0x4019a3
            // 0x4019a3
            // branch -> 0x4019f4
            // 0x4019f4
            return (int32_t)v13;
        }
        // 0x401842
        SetDlgItemTextA(&a1->e0, 2000, "error: this flag is not allowed");
        // branch -> 0x40196e
        // 0x40196e
        *(int32_t *)(g6 - 4) = g43;
        CloseHandle((int32_t *)hObject2);
        *(int32_t *)(g6 - 4) = g38;
        GlobalUnlock((int32_t *)hObject2);
        *(int32_t *)(g6 - 4) = g37;
        result4 = (int32_t)GlobalFree((int32_t *)hObject2);
        // branch -> 0x4019a3
    }
    // 0x4019a3
    // branch -> 0x4019f4
    // 0x4019f4
    return result4;
}

// Address range: 0x4019f8 - 0x401a78
int32_t function_4019f8(void) {
    // 0x4019f8
    RegCreateKeyExA(HKEY_CURRENT_USER, "SOFTWARE\\HACKvent2018", 0, NULL, 0, 0x4001f, NULL, (int32_t **)&g44, NULL);
    RegQueryInfoKeyA((int32_t *)g44, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, (struct _FILETIME *)&g21);
    RegCloseKey((int32_t *)g44);
    FileTimeToSystemTime((struct _FILETIME *)&g21, (struct _SYSTEMTIME *)&g22);
    SystemTimeToFileTime((struct _SYSTEMTIME *)&g22, (struct _FILETIME *)&g21);
    return RegDeleteKeyA((int32_t *)-0x7fffffff, "SOFTWARE\\HACKvent2018");
}

// Address range: 0x401a78 - 0x401aeb
int32_t function_401a78(int32_t * hWnd) {
    // 0x401a78
    GetWindowRect(hWnd, (struct tagRECT *)&g24);
    int32_t * hWnd2 = GetDesktopWindow(); // 0x401a89
    GetWindowRect(hWnd2, (struct tagRECT *)&g28);
    int32_t nHeight = g27 - g25; // 0x401a9e
    int32_t nWidth = g26 - (int32_t)g24; // 0x401aac
    MoveWindow(hWnd, (g29 - nWidth) / 2, (g30 - nHeight) / 2, nWidth, nHeight, true);
    return 0;
}

// Address range: 0x401aeb - 0x401af1
int32_t function_401aeb(int32_t * hKey, char * lpSubKey, int32_t Reserved, char * lpClass, int32_t dwOptions, int32_t samDesired, struct _SECURITY_ATTRIBUTES * lpSecurityAttributes, int32_t ** phkResult, int32_t * lpdwDisposition) {
    // 0x401aeb
    return RegCreateKeyExA(hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);
}

// Address range: 0x401af1 - 0x401af7
int32_t function_401af1(int32_t * hKey) {
    // 0x401af1
    return RegCloseKey(hKey);
}

// Address range: 0x401af7 - 0x401afd
int32_t function_401af7(int32_t * hKey, char * lpClass, int32_t * lpcchClass, int32_t * lpReserved, int32_t * lpcSubKeys, int32_t * lpcbMaxSubKeyLen, int32_t * lpcbMaxClassLen, int32_t * lpcValues, int32_t * lpcbMaxValueNameLen, int32_t * lpcbMaxValueLen, int32_t * lpcbSecurityDescriptor, struct _FILETIME * lpftLastWriteTime) {
    // 0x401af7
    return RegQueryInfoKeyA(hKey, lpClass, lpcchClass, lpReserved, lpcSubKeys, lpcbMaxSubKeyLen, lpcbMaxClassLen, lpcValues, lpcbMaxValueNameLen, lpcbMaxValueLen, lpcbSecurityDescriptor, lpftLastWriteTime);
}

// Address range: 0x401afd - 0x401b03
int32_t function_401afd(int32_t * hKey, char * lpSubKey) {
    // 0x401afd
    return RegDeleteKeyA(hKey, lpSubKey);
}

// Address range: 0x401b03 - 0x401b09
int32_t * function_401b03(char * lpFileName, int32_t dwDesiredAccess, int32_t dwShareMode, struct _SECURITY_ATTRIBUTES * lpSecurityAttributes, int32_t dwCreationDisposition, int32_t dwFlagsAndAttributes, int32_t * hTemplateFile) {
    // 0x401b03
    return CreateFileA(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
}

// Address range: 0x401b09 - 0x401b0f
bool function_401b09(int32_t * hObject) {
    // 0x401b09
    return CloseHandle(hObject);
}

// Address range: 0x401b0f - 0x401b15
int32_t * function_401b0f(int32_t * hMem) {
    // 0x401b0f
    return GlobalFree(hMem);
}

// Address range: 0x401b15 - 0x401b1b
int32_t * function_401b15(char * lpModuleName) {
    // 0x401b15
    return GetModuleHandleA(lpModuleName);
}

// Address range: 0x401b1b - 0x401b21
bool function_401b1b(int32_t * hMem) {
    // 0x401b1b
    return GlobalUnlock(hMem);
}

// Address range: 0x401b21 - 0x401b27
void function_401b21(int32_t uExitCode) {
    // 0x401b21
    ExitProcess(uExitCode);
}

// Address range: 0x401b27 - 0x401b2d
bool function_401b27(struct _FILETIME * lpFileTime, struct _SYSTEMTIME * lpSystemTime) {
    // 0x401b27
    return FileTimeToSystemTime(lpFileTime, lpSystemTime);
}

// Address range: 0x401b2d - 0x401b33
bool function_401b2d(int32_t * hFile, int32_t * lpBuffer, int32_t nNumberOfBytesToWrite, int32_t * lpNumberOfBytesWritten, struct _OVERLAPPED * lpOverlapped) {
    // 0x401b2d
    return WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);
}

// Address range: 0x401b33 - 0x401b39
bool function_401b33(int32_t * hFile, int32_t * lpBuffer, int32_t nNumberOfBytesToRead, int32_t * lpNumberOfBytesRead, struct _OVERLAPPED * lpOverlapped) {
    // 0x401b33
    return ReadFile(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped);
}

// Address range: 0x401b39 - 0x401b3f
int32_t * function_401b39(int32_t uFlags, int32_t dwBytes) {
    // 0x401b39
    return GlobalAlloc(uFlags, dwBytes);
}

// Address range: 0x401b3f - 0x401b45
bool function_401b3f(struct _SYSTEMTIME * lpSystemTime, struct _FILETIME * lpFileTime) {
    // 0x401b3f
    return SystemTimeToFileTime(lpSystemTime, lpFileTime);
}

// Address range: 0x401b45 - 0x401b4b
int32_t function_401b45(int32_t * hFile, int32_t * lpFileSizeHigh) {
    // 0x401b45
    return GetFileSize(hFile, lpFileSizeHigh);
}

// Address range: 0x401b4b - 0x401b51
int32_t * function_401b4b(int32_t * hMem) {
    // 0x401b4b
    return GlobalLock(hMem);
}

// Address range: 0x401b51 - 0x401b57
int32_t * function_401b51(int32_t cHeight, int32_t cWidth, int32_t cEscapement, int32_t cOrientation, int32_t cWeight, int32_t bItalic, int32_t bUnderline, int32_t bStrikeOut, int32_t iCharSet, int32_t iOutPrecision, int32_t iClipPrecision, int32_t iQuality, int32_t iPitchAndFamily, char * pszFaceName) {
    // 0x401b51
    return CreateFontA(cHeight, cWidth, cEscapement, cOrientation, cWeight, bItalic, bUnderline, bStrikeOut, iCharSet, iOutPrecision, iClipPrecision, iQuality, iPitchAndFamily, pszFaceName);
}

// Address range: 0x401b57 - 0x401b5d
void function_401b57(int32_t nExitCode) {
    // 0x401b57
    PostQuitMessage(nExitCode);
}

// Address range: 0x401b5d - 0x401b63
bool function_401b5d(int32_t * hWnd, int32_t Msg, int32_t wParam, int32_t lParam) {
    // 0x401b5d
    return PostMessageA(hWnd, Msg, wParam, lParam);
}

// Address range: 0x401b63 - 0x401b69
bool function_401b63(int32_t * hWnd, int32_t X, int32_t Y, int32_t nWidth, int32_t nHeight, bool bRepaint) {
    // 0x401b63
    return MoveWindow(hWnd, X, Y, nWidth, nHeight, bRepaint);
}

// Address range: 0x401b69 - 0x401b6f
int32_t * function_401b69(int32_t * hInstance, char * lpCursorName) {
    // 0x401b69
    return LoadCursorA(hInstance, lpCursorName);
}

// Address range: 0x401b6f - 0x401b75
bool function_401b6f(int32_t * hDlg, struct tagMSG * lpMsg) {
    // 0x401b6f
    return IsDialogMessageA(hDlg, lpMsg);
}

// Address range: 0x401b75 - 0x401b7b
bool function_401b75(int32_t * hWnd, struct tagRECT * lpRect) {
    // 0x401b75
    return GetWindowRect(hWnd, lpRect);
}

// Address range: 0x401b7b - 0x401b81
bool function_401b7b(struct tagMSG * lpMsg, int32_t * hWnd, int32_t wMsgFilterMin, int32_t wMsgFilterMax) {
    // 0x401b7b
    return GetMessageA(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax);
}

// Address range: 0x401b81 - 0x401b87
int32_t * function_401b81(int32_t * hInstance, char * lpIconName) {
    // 0x401b81
    return LoadIconA(hInstance, lpIconName);
}

// Address range: 0x401b87 - 0x401b8d
int32_t * function_401b87(void) {
    // 0x401b87
    return GetDesktopWindow();
}

// Address range: 0x401b8d - 0x401b93
int32_t function_401b8d(struct tagMSG * lpMsg) {
    // 0x401b8d
    return DispatchMessageA(lpMsg);
}

// Address range: 0x401b93 - 0x401b99
int32_t function_401b93(int32_t * hWnd, int32_t Msg, int32_t wParam, int32_t lParam) {
    // 0x401b93
    return DefWindowProcA(hWnd, Msg, wParam, lParam);
}

// Address range: 0x401b99 - 0x401b9f
int16_t function_401b99(struct tagWNDCLASSEXA * lpwcx) {
    // 0x401b99
    return RegisterClassExA(lpwcx);
}

// Address range: 0x401b9f - 0x401ba5
int32_t * function_401b9f(int32_t dwExStyle, char * lpClassName, char * lpWindowName, int32_t dwStyle, int32_t X, int32_t Y, int32_t nWidth, int32_t nHeight, int32_t * hWndParent, int32_t * hMenu, int32_t * hInstance, int32_t * lpParam) {
    // 0x401b9f
    return CreateWindowExA(dwExStyle, lpClassName, lpWindowName, dwStyle, X, Y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);
}

// Address range: 0x401ba5 - 0x401bab
bool function_401ba5(int32_t * hWnd) {
    // 0x401ba5
    return UpdateWindow(hWnd);
}

// Address range: 0x401bab - 0x401bb1
bool function_401bab(struct tagMSG * lpMsg) {
    // 0x401bab
    return TranslateMessage(lpMsg);
}

// Address range: 0x401bb1 - 0x401bb7
bool function_401bb1(int32_t * hWnd, int32_t nCmdShow) {
    // 0x401bb1
    return ShowWindow(hWnd, nCmdShow);
}

// Address range: 0x401bb7 - 0x401bbd
int32_t * function_401bb7(int32_t * hWnd) {
    // 0x401bb7
    return SetFocus(hWnd);
}

// Address range: 0x401bbd - 0x401bc3
bool function_401bbd(int32_t * hDlg, int32_t nIDDlgItem, char * lpString) {
    // 0x401bbd
    return SetDlgItemTextA(hDlg, nIDDlgItem, lpString);
}

// Address range: 0x401bc3 - 0x401bc9
int32_t function_401bc3(int32_t * hDlg, int32_t nIDDlgItem, int32_t Msg, int32_t wParam, int32_t lParam) {
    // 0x401bc3
    return SendDlgItemMessageA(hDlg, nIDDlgItem, Msg, wParam, lParam);
}

// --------------- Dynamically Linked Functions ---------------

// BOOL CloseHandle(_In_ HANDLE hObject);
// HANDLE CreateFileA(_In_ LPCSTR lpFileName, _In_ DWORD dwDesiredAccess, _In_ DWORD dwShareMode, _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes, _In_ DWORD dwCreationDisposition, _In_ DWORD dwFlagsAndAttributes, _In_opt_ HANDLE hTemplateFile);
// HFONT CreateFontA(_In_ int cHeight, _In_ int cWidth, _In_ int cEscapement, _In_ int cOrientation, _In_ int cWeight, _In_ DWORD bItalic, _In_ DWORD bUnderline, _In_ DWORD bStrikeOut, _In_ DWORD iCharSet, _In_ DWORD iOutPrecision, _In_ DWORD iClipPrecision, _In_ DWORD iQuality, _In_ DWORD iPitchAndFamily, _In_opt_ LPCSTR pszFaceName);
// HWND CreateWindowExA(_In_ DWORD dwExStyle, _In_opt_ LPCSTR lpClassName, _In_opt_ LPCSTR lpWindowName, _In_ DWORD dwStyle, _In_ int X, _In_ int Y, _In_ int nWidth, _In_ int nHeight, _In_opt_ HWND hWndParent, _In_opt_ HMENU hMenu, _In_opt_ HINSTANCE hInstance, _In_opt_ LPVOID lpParam);
// LRESULT DefWindowProcA(_In_ HWND hWnd, _In_ UINT Msg, _In_ WPARAM wParam, _In_ LPARAM lParam);
// LRESULT DispatchMessageA(_In_ const MSG * lpMsg);
// VOID ExitProcess(_In_ UINT uExitCode);
// BOOL FileTimeToSystemTime(_In_ const FILETIME * lpFileTime, _Out_ LPSYSTEMTIME lpSystemTime);
// HWND GetDesktopWindow(VOID);
// DWORD GetFileSize(_In_ HANDLE hFile, _Out_opt_ LPDWORD lpFileSizeHigh);
// BOOL GetMessageA(_Out_ LPMSG lpMsg, _In_opt_ HWND hWnd, _In_ UINT wMsgFilterMin, _In_ UINT wMsgFilterMax);
// HMODULE GetModuleHandleA(_In_opt_ LPCSTR lpModuleName);
// BOOL GetWindowRect(_In_ HWND hWnd, _Out_ LPRECT lpRect);
// HGLOBAL GlobalAlloc(_In_ UINT uFlags, _In_ SIZE_T dwBytes);
// HGLOBAL GlobalFree(HGLOBAL hMem);
// LPVOID GlobalLock(_In_ HGLOBAL hMem);
// BOOL GlobalUnlock(_In_ HGLOBAL hMem);
// BOOL IsDialogMessageA(_In_ HWND hDlg, _In_ LPMSG lpMsg);
// HCURSOR LoadCursorA(_In_opt_ HINSTANCE hInstance, _In_ LPCSTR lpCursorName);
// HICON LoadIconA(_In_opt_ HINSTANCE hInstance, _In_ LPCSTR lpIconName);
// BOOL MoveWindow(_In_ HWND hWnd, _In_ int X, _In_ int Y, _In_ int nWidth, _In_ int nHeight, _In_ BOOL bRepaint);
// BOOL PostMessageA(_In_opt_ HWND hWnd, _In_ UINT Msg, _In_ WPARAM wParam, _In_ LPARAM lParam);
// VOID PostQuitMessage(_In_ int nExitCode);
// BOOL ReadFile(_In_ HANDLE hFile, LPVOID lpBuffer, _In_ DWORD nNumberOfBytesToRead, _Out_opt_ LPDWORD lpNumberOfBytesRead, _Inout_opt_ LPOVERLAPPED lpOverlapped);
// LSTATUS RegCloseKey(_In_ HKEY hKey);
// LSTATUS RegCreateKeyExA(_In_ HKEY hKey, _In_ LPCSTR lpSubKey, DWORD Reserved, _In_opt_ LPSTR lpClass, _In_ DWORD dwOptions, _In_ REGSAM samDesired, _In_opt_ const LPSECURITY_ATTRIBUTES lpSecurityAttributes, _Out_ PHKEY phkResult, _Out_opt_ LPDWORD lpdwDisposition);
// LSTATUS RegDeleteKeyA(_In_ HKEY hKey, _In_ LPCSTR lpSubKey);
// ATOM RegisterClassExA(_In_ const WNDCLASSEXA *);
// LSTATUS RegQueryInfoKeyA(_In_ HKEY hKey, LPSTR lpClass, _Inout_opt_ LPDWORD lpcchClass, LPDWORD lpReserved, _Out_opt_ LPDWORD lpcSubKeys, _Out_opt_ LPDWORD lpcbMaxSubKeyLen, _Out_opt_ LPDWORD lpcbMaxClassLen, _Out_opt_ LPDWORD lpcValues, _Out_opt_ LPDWORD lpcbMaxValueNameLen, _Out_opt_ LPDWORD lpcbMaxValueLen, _Out_opt_ LPDWORD lpcbSecurityDescriptor, _Out_opt_ PFILETIME lpftLastWriteTime);
// LRESULT SendDlgItemMessageA(_In_ HWND hDlg, _In_ int nIDDlgItem, _In_ UINT Msg, _In_ WPARAM wParam, _In_ LPARAM lParam);
// BOOL SetDlgItemTextA(_In_ HWND hDlg, _In_ int nIDDlgItem, _In_ LPCSTR lpString);
// HWND SetFocus(_In_opt_ HWND hWnd);
// BOOL ShowWindow(_In_ HWND hWnd, _In_ int nCmdShow);
// BOOL SystemTimeToFileTime(_In_ const SYSTEMTIME * lpSystemTime, _Out_ LPFILETIME lpFileTime);
// BOOL TranslateMessage(_In_ const MSG * lpMsg);
// BOOL UpdateWindow(_In_ HWND hWnd);
// BOOL WriteFile(_In_ HANDLE hFile, LPCVOID lpBuffer, _In_ DWORD nNumberOfBytesToWrite, _Out_opt_ LPDWORD lpNumberOfBytesWritten, _Inout_opt_ LPOVERLAPPED lpOverlapped);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: fasm
// Detected functions: 47
// Decompilation date: 2018-12-31 05:53:43
